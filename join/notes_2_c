 Each of them is the result of the threads getting scheduled in different orders. Let's think about this more. In particular, think about what's going on after the main thread calls pthread_create() for the first time. At that point, there are two threads -- the main thread and thread 0. Either of them can run, and it's up to the operating system to select one. If the operating system is managing two processors, it may choose to run each thread simultaneously on a different processor.
If thread 0 gets control first, you'll see the output "Hi. I'm thread 0" first. If the main thread gets control first, then it will call pthread_create() for thread 1, and you'll have three threads that can all run. For each output above, you can derive an ordering of the threads that generates the output. For example in that last output, the main thread creates thread 2 before the first line of output is printed, and that line is printed by thread 2.

This is simultaneously what makes threaded programs great and difficult. They are great because they allow multiple threads to run at the same time (either on different processors, or on one processor, scheduled by the operating system). They are difficult for the same reason. One of the challenged of this type of programming is allowing for the threads to do as much as they can simultaneously without getting yourself in trouble.
